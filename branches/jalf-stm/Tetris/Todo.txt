STM Version
-----------
- Review unit tests. Try to identify which ones are essential. Which ones are missing? This is the basis on which I can start the refactoring to nested transactions.
- LinesCleared and GameStateChanged should not be called from within transaction.
v Occasional crashes.
v Survival mode is slow and choppy.
v Sync errors.
v On Mac the FPS is very slow.
v Use STM in TreeRowInfos
v Future blocks shows current block as next block.
v Check out Google Perftools (http://code.google.com/p/google-perftools/wiki/GooglePerformanceTools)
v Remove Computer's dependency to MainThread.
v There is something wrong with the block types: BlockType_I appears twice.
v Restore unit-test build.
v Fix the working of the program
v Improve encapsulation by obeying the Law of Demeter


STM Notes
--------
- Memory is not the only resource. The biggest realization is that not all resources are memory. Access to streams, thread-schedulers, require old fashioned locking. This leads to sitations where I have to "jump through hoops" to keep the locking outside of the transactions. Logging is a simple example. Also in Computer.cpp I recall a few thing. I have to check for concrete examples.
- Uncertainty. This may be due to lack of experience. If you open an object for reading, then later re-open it within the same transaction but  writing and modify and commit it. Will the original object that was opened for reading be updated. The answer is, iirc, no. This makes me sometimes feel uncertain if my code is correct.
- Lot's of experimentation required in order to find which idioms/practices work well. Currently I've settled on these:
    . Nested transactions seem to be the way to go.
    . Extensive use of the "Law of demeter"
    . Pimpl to avoid exposing stm in the public header files.


- This feature could be helpful:
    @StackedCrooked btw, if you need something like a condition variable in the STM lib,
    simply open the variables you want to wait for changes in, check their value, and
    call transaction::retry(). In an ideal world, it'd then suspend the thread until
    one of your opened variables is modified. In the current implementation, it's basically
    a busy loop, so much less efficient, but the effect is the same :)


